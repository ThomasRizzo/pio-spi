# PIO SPI Master for RP2350

Half-duplex SPI master implementation using the RP2350's Programmable Input/Output (PIO) module with configurable message sizes (16-60 bits).

## Goals

This repository demonstrates the development of a working embedded systems library using only AI agents. All code, documentation, and design decisions are generated by AI—no human commits have been made to any project files. The objective is to create a functional SPI driver that leverages the RP2350's PIO hardware while maintaining clean, maintainable code through AI-driven development practices.

## Features

- **Configurable message size** (16-60 bits per transfer)
- **Multiple state machines**: SM0, SM1, SM2 can operate independently with different message sizes
- **Full-duplex operation**: Write phase followed by read phase (same bit count)
- **PIO-based**: Uses RP2350's dedicated PIO hardware, freeing up main CPU
- **Configurable clock divider** for flexible SPI speeds
- **Auto-fill FIFO mode** for seamless multi-word transfers (e.g., 50 bits across two 32-bit FIFO words)
- **Unified PIO program** (~20 instructions, fits easily in 32-instruction memory)
- **Dual API**: `transfer()` for full-duplex, `write()` for write-only

## Message Format

For a transfer with `message_size` bits:

```
Bits [message_size-1:0]    Data to transmit on MOSI
Bits [63:message_size]     Unused/padding
```

Example for 50-bit transfers:
```
Bits [49:0]    50-bit data to transmit on MOSI
Bits [63:50]   Unused (padding)
```

## Pin Configuration

```
GPIO Pin → PIO Function → SPI Signal
PIN_2    → SET pins    → CLK (Clock)
PIN_3    → OUT pins    → MOSI (Output)
PIN_4    → IN pins     → MISO (Input)
PIN_5    → GPIO Output → CS (Chip Select, optional)
```

Pins are configurable when creating the `PioSpiMaster`.

## Usage Example

```rust
use embassy_rp::peripherals::PIO0;
use embassy_rp::pio::Pio;
use pio_spi::{PioSpiMaster, SpiMasterConfig};

// Initialize PIO
let Pio { mut common, sm0, sm1, .. } = Pio::new(p.PIO0, Irqs);

// Create PIO pins
let clk = common.make_pio_pin(p.PIN_2);
let mosi = common.make_pio_pin(p.PIN_3);
let miso = common.make_pio_pin(p.PIN_4);

// Configure SM0 for 16-bit transfers on PIO0
let config_16bit = SpiMasterConfig {
    clk_div: 8,
    message_size: 16,
};
let mut spi_16 = PioSpiMaster::<PIO0, 0>::new(
    &mut common,
    sm0,
    &clk,
    &mosi,
    &miso,
    config_16bit,
);

// Configure SM1 for 50-bit transfers on PIO0
let config_50bit = SpiMasterConfig {
    clk_div: 8,
    message_size: 50,
};
let mut spi_50 = PioSpiMaster::<PIO0, 1>::new(
    &mut common,
    sm1,
    &clk,
    &mosi,
    &miso,
    config_50bit,
);

// 16-bit full-duplex transfer (write then read)
let response_16 = spi_16.transfer(0xABCD_u64);
println!("Received: 0x{:04x}", response_16 & 0xFFFF);

// 50-bit full-duplex transfer
let response_50 = spi_50.transfer(0x0123456789_u64);
println!("Received: 0x{:012x}", response_50);

// Write-only transfer (no waiting for response)
spi_16.write(0x1234_u64);
```

## Protocol

1. **Initialization**:
   - Host pushes `message_size` (bit count) to TX FIFO once
   - PIO reads it and stores in Y register (used for all subsequent transfers)

2. **Per-Transfer Write Phase**:
   - Host pushes message_size bits to TX FIFO (split into 32-bit words as needed)
   - PIO shifts out message_size bits to MOSI, toggling CLK for each bit
   - TX FIFO auto-fill refills OSR as bits are shifted

3. **Per-Transfer Read Phase**:
   - PIO shifts in message_size bits from MISO, toggling CLK for each bit
   - ISR accumulates bits, auto-pushes to RX FIFO at configured threshold

4. **Data Flow Example** (50-bit transfer):
   - Init: Host pushes 50 to TX FIFO (bit count)
   - Transfer: Host pushes 2×32-bit words (50 bits + 14 padding bits)
   - PIO reads bit count (50), shifts out 50 bits with auto-fill
   - PIO shifts in 50 bits, ISR auto-pushes at 32-bit and 18-bit boundaries
   - Host reads 2×32-bit words from RX FIFO

## Implementation Details

### PIO Program Structure

The program uses a unified, configurable loop that handles any message size (16-60 bits):

```pio
set pins, 1              # Initialize CLK HIGH
pull block               # Load message_size from TX FIFO
mov y, osr               # Y = bit count (loop counter)

.wrap_target
  mov x, y               # Copy Y to X (write loop counter)
  loop_write:
    out pins, 1          # Shift 1 bit from OSR to MOSI (write phase)
    set pins, 0          # CLK low
    set pins, 1          # CLK high
    jmp x--, loop_write  # Repeat until X reaches 0
  out null, 32           # Clear remaining OSR bits (triggers auto-push)
  
  mov x, y               # Copy Y to X (read loop counter)
  loop_read:
    in pins, 1           # Shift 1 bit from MISO (read phase)
    set pins, 0          # CLK low
    set pins, 1          # CLK high
    jmp x--, loop_read   # Repeat until X reaches 0
  push noblock           # Push any remaining read bits
.wrap
```

**Key points:**
- Y register holds message_size (set once at initialization)
- X register is the per-transfer counter (copied from Y for each loop)
- Write loop executes X times, shifting 1 bit to MOSI each iteration
- Read loop executes X times, shifting 1 bit from MISO each iteration
- Auto-fill refills OSR from TX FIFO as bits are shifted during write phase
- Auto-push flushes ISR to RX FIFO at configured threshold during read phase
- Both phases use identical CLK toggle pattern for timing consistency
- Works for any message size; no recompilation needed

### Register Usage

- **Y register**: Message size (bit count), loaded once at initialization, reused for all transfers
- **X register**: Per-transfer loop counter, copied from Y before each transfer
- **OSR (Output Shift Register)**: Holds TX data, auto-fills from TX FIFO as bits are shifted
- **ISR (Input Shift Register)**: Holds RX data, auto-pushed to RX FIFO at threshold

### FIFO Configuration

- **TX FIFO**: Auto-fill enabled; refills OSR when exhausted (at 32-bit boundaries)
- **RX FIFO**: Auto-push at configurable threshold (set to min(message_size, 32) bits)
- **Mode**: Duplex (separate TX/RX, but sequential write-then-read per transfer)
- **Timing**: SPI Mode 0 (CPOL=0, CPHA=0) - data sampled after CLK rising edge

## Clock Divider

The `clk_div` parameter controls SPI clock frequency:
- `clk_div = 1`: Fastest (1 PIO clock per bit + overhead)
- `clk_div = 8`: Common setting for 125 MHz → ~15 MHz SPI
- `clk_div = 256`: Slowest (frequency scaling)

Actual SPI frequency depends on bit timing and RP2350 system clock.

## Design Notes

### Configurable Message Size (16-60 bits)

The program supports any message size by reading the bit count from TX FIFO at initialization:
- Single `pull block` reads message_size once
- Y register stores it for the lifetime of the state machine
- Each transfer uses Y as the loop counter
- No recompilation needed; different state machines can run different sizes

### Why Auto-Fill and Auto-Push?

- **TX Auto-fill**: Refills OSR from TX FIFO as bits are shifted, enabling seamless multi-word transfers
  - Example: 50-bit transfer uses 2×32-bit FIFO words; OSR auto-refills at 32-bit boundary
- **RX Auto-push**: Flushes ISR to RX FIFO at configured threshold, preventing deadlock
  - Threshold set to `min(message_size, 32)` to match hardware limits
  - Example: 50-bit message pushes at 32 bits and 18 bits

### Why Single Unified Loop?

- Original design had separate write/read loops for 50-bit mode
- Unified loop handles any size (16-60) with identical logic
- Fewer instructions (~12 vs 32), more flexibility, same performance
- Trade-off: Requires pushing message_size to TX FIFO at init time

## Dependencies

- `embassy-rp` 0.9.0+: RP2350 Hardware Abstraction Layer
- `pio` 0.3.0+: PIO assembler with macro support
- `fixed` 1.0+: Fixed-point arithmetic for clock divider

## Limitations

- **Sequential duplex**: Writes then reads (cannot TX and RX simultaneously on same bits)
- **Fixed per-SM size**: Message size set at state machine initialization, same for all transfers on that SM
- **Blocking**: `transfer()` waits for completion (no interrupt/async support)
- **Manual FIFO management**: Caller must push correct number of TX FIFO words and read RX results

## Performance

- **Write + Read**: ~50 bits + overhead ≈ 50-100 PIO cycles
- **Throughput**: ~1.25-2.5 Mbps at `clk_div=8` (depends on bit timing)
- **Latency**: Microsecond-level with proper clock divisor selection

## Testing

```bash
cargo check --lib      # Check library compilation
cargo build --release  # Release build
```

## Future Enhancements

- Async/await support with interrupt-driven completion
- Per-transfer variable message size (currently fixed at SM initialization)
- Simultaneous TX/RX on separate pins (currently sequential on same pins)
- Built-in chip select management
- Clock polarity/phase configuration
- Support for RP2040 (currently RP2350)
- DMA integration for high-throughput transfers

## References

- [RP2350 Datasheet](https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf)
- [Embassy Documentation](https://embassy.dev/)
- [PIO Assembly](https://docs.rs/pio/0.3.0/pio/)

## License

MIT OR Apache-2.0
